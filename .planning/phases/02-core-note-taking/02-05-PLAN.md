---
phase: 02-core-note-taking
plan: 05
type: execute
wave: 4
depends_on: ["02-03", "02-04"]
files_modified:
  - apps/mobile/app/(app)/search/index.tsx
  - apps/mobile/app/(app)/notes/_layout.tsx
  - apps/mobile/components/markdown/MarkdownRenderer.tsx
  - apps/mobile/components/markdown/MarkdownEditor.tsx
  - apps/mobile/components/notes/MoveNoteModal.tsx
  - apps/mobile/app/(app)/notes/[id].tsx
autonomous: false

must_haves:
  truths:
    - "User can search across all note content"
    - "Search results show highlighted snippets"
    - "User can toggle between edit and preview modes"
    - "Markdown renders correctly with formatting"
    - "User can move notes between folders"
  artifacts:
    - path: "apps/mobile/app/(app)/search/index.tsx"
      provides: "Search screen with results"
      min_lines: 80
    - path: "apps/mobile/components/markdown/MarkdownRenderer.tsx"
      provides: "Markdown rendering component"
      min_lines: 30
    - path: "apps/mobile/components/markdown/MarkdownEditor.tsx"
      provides: "Edit/preview toggle editor"
      min_lines: 60
    - path: "apps/mobile/components/notes/MoveNoteModal.tsx"
      provides: "Folder picker for moving notes"
      min_lines: 60
  key_links:
    - from: "apps/mobile/app/(app)/search/index.tsx"
      to: "@/db/queries"
      via: "searchNotes function"
      pattern: "searchNotes"
    - from: "apps/mobile/components/markdown/MarkdownRenderer.tsx"
      to: "react-native-markdown-display"
      via: "Markdown component"
      pattern: "from.*react-native-markdown-display"
    - from: "apps/mobile/app/(app)/notes/[id].tsx"
      to: "apps/mobile/components/notes/MoveNoteModal.tsx"
      via: "move action"
      pattern: "MoveNoteModal"
---

<objective>
Complete Phase 2 with search, markdown rendering, and move note functionality

Purpose: Finish the note-taking feature set by adding search capabilities, proper markdown display, and the ability to organize notes by moving them between folders. This completes all 5 success criteria.

Output: Full search screen, markdown editor with preview toggle, and move note modal.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-note-taking/02-RESEARCH.md

# Prior plan outputs
@apps/mobile/db/queries/search.ts
@apps/mobile/app/(app)/notes/[id].tsx
@apps/mobile/app/(app)/notes/index.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create search screen with FTS5 results</name>
  <files>
    apps/mobile/app/(app)/search/index.tsx
    apps/mobile/app/(app)/search/_layout.tsx
    apps/mobile/app/(app)/_layout.tsx
  </files>
  <action>
First install react-native-markdown-display:
```bash
cd apps/mobile
pnpm add react-native-markdown-display
```

Create apps/mobile/app/(app)/search/_layout.tsx:
```typescript
import { Stack } from "expo-router";

export default function SearchLayout() {
  return (
    <Stack screenOptions={{ headerShown: true }}>
      <Stack.Screen name="index" options={{ title: "Search" }} />
    </Stack>
  );
}
```

Create apps/mobile/app/(app)/search/index.tsx:
```typescript
import { useState, useCallback } from "react";
import {
  View,
  TextInput,
  FlatList,
  TouchableOpacity,
  Text,
  StyleSheet,
  ActivityIndicator,
} from "react-native";
import { router } from "expo-router";
import { Ionicons } from "@expo/vector-icons";
import { searchNotes, getRecentNotes, type SearchResult } from "@/db/queries";
import { useFocusEffect } from "expo-router";

export default function SearchScreen() {
  const [query, setQuery] = useState("");
  const [results, setResults] = useState<SearchResult[]>([]);
  const [recentNotes, setRecentNotes] = useState<SearchResult[]>([]);
  const [loading, setLoading] = useState(false);

  // Load recent notes on focus
  useFocusEffect(
    useCallback(() => {
      getRecentNotes(10).then(setRecentNotes);
    }, [])
  );

  const handleSearch = async (text: string) => {
    setQuery(text);

    if (!text.trim()) {
      setResults([]);
      return;
    }

    setLoading(true);
    try {
      const searchResults = await searchNotes(text);
      setResults(searchResults);
    } catch (error) {
      console.error("Search error:", error);
      setResults([]);
    } finally {
      setLoading(false);
    }
  };

  const displayResults = query.trim() ? results : recentNotes;
  const showingRecent = !query.trim();

  return (
    <View style={styles.container}>
      {/* Search Input */}
      <View style={styles.searchContainer}>
        <Ionicons name="search" size={20} color="#999" style={styles.searchIcon} />
        <TextInput
          style={styles.searchInput}
          placeholder="Search notes..."
          placeholderTextColor="#999"
          value={query}
          onChangeText={handleSearch}
          autoFocus
          returnKeyType="search"
        />
        {query.length > 0 && (
          <TouchableOpacity onPress={() => handleSearch("")}>
            <Ionicons name="close-circle" size={20} color="#999" />
          </TouchableOpacity>
        )}
      </View>

      {/* Section Header */}
      {showingRecent && recentNotes.length > 0 && (
        <Text style={styles.sectionHeader}>Recent Notes</Text>
      )}

      {/* Loading Indicator */}
      {loading && (
        <View style={styles.loadingContainer}>
          <ActivityIndicator size="small" color="#007AFF" />
        </View>
      )}

      {/* Results List */}
      {!loading && (
        <FlatList
          data={displayResults}
          keyExtractor={(item) => item.id.toString()}
          renderItem={({ item }) => (
            <TouchableOpacity
              style={styles.resultCard}
              onPress={() => router.push(`/notes/${item.id}`)}
            >
              <Text style={styles.resultTitle} numberOfLines={1}>
                {item.title}
              </Text>
              <Text style={styles.resultSnippet} numberOfLines={2}>
                {showingRecent
                  ? item.contentSnippet
                  : item.contentSnippet.replace(/<\/?mark>/g, "")}
              </Text>
            </TouchableOpacity>
          )}
          ListEmptyComponent={
            query.trim() ? (
              <View style={styles.emptyContainer}>
                <Ionicons name="search" size={48} color="#C7C7CC" />
                <Text style={styles.emptyText}>No results found</Text>
                <Text style={styles.emptyHint}>Try different keywords</Text>
              </View>
            ) : null
          }
          contentContainerStyle={styles.listContent}
        />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#F2F2F7",
  },
  searchContainer: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: "#fff",
    margin: 16,
    paddingHorizontal: 12,
    borderRadius: 10,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  searchIcon: {
    marginRight: 8,
  },
  searchInput: {
    flex: 1,
    paddingVertical: 12,
    fontSize: 16,
    color: "#1a1a1a",
  },
  sectionHeader: {
    fontSize: 13,
    fontWeight: "600",
    color: "#666",
    textTransform: "uppercase",
    marginHorizontal: 16,
    marginBottom: 8,
  },
  loadingContainer: {
    padding: 20,
    alignItems: "center",
  },
  listContent: {
    paddingBottom: 20,
  },
  resultCard: {
    backgroundColor: "#fff",
    marginHorizontal: 16,
    marginVertical: 6,
    padding: 16,
    borderRadius: 12,
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  resultTitle: {
    fontSize: 17,
    fontWeight: "600",
    color: "#1a1a1a",
    marginBottom: 4,
  },
  resultSnippet: {
    fontSize: 14,
    color: "#666",
    lineHeight: 20,
  },
  emptyContainer: {
    alignItems: "center",
    padding: 48,
  },
  emptyText: {
    fontSize: 18,
    fontWeight: "600",
    color: "#666",
    marginTop: 16,
  },
  emptyHint: {
    fontSize: 14,
    color: "#999",
    marginTop: 8,
  },
});
```

Update apps/mobile/app/(app)/_layout.tsx to include search:
```typescript
import { Stack } from "expo-router";

export default function AppLayout() {
  return (
    <Stack screenOptions={{ headerShown: false }}>
      <Stack.Screen name="home" />
      <Stack.Screen name="notes" />
      <Stack.Screen name="search" />
    </Stack>
  );
}
```

Add search button to notes index screen header. Update apps/mobile/app/(app)/notes/index.tsx to include:
```typescript
// In the component, before return:
<Stack.Screen
  options={{
    title: "Notes",
    headerRight: () => (
      <TouchableOpacity
        onPress={() => router.push("/search")}
        style={{ padding: 8 }}
      >
        <Ionicons name="search" size={24} color="#007AFF" />
      </TouchableOpacity>
    ),
  }}
/>
```

Import Stack from expo-router in notes/index.tsx if not already.
  </action>
  <verify>
- Search screen exists at apps/mobile/app/(app)/search/index.tsx
- Navigating to /search shows search input
- Typing triggers search and shows results
- Tapping result navigates to note editor
- Recent notes show when search is empty
- Search icon in notes header navigates to search
- TypeScript compiles: `cd apps/mobile && pnpm exec tsc --noEmit`
  </verify>
  <done>Search screen with FTS5 integration, recent notes fallback, and navigation complete</done>
</task>

<task type="auto">
  <name>Task 2: Create markdown editor with preview toggle</name>
  <files>
    apps/mobile/components/markdown/MarkdownRenderer.tsx
    apps/mobile/components/markdown/MarkdownEditor.tsx
    apps/mobile/app/(app)/notes/[id].tsx
  </files>
  <action>
Create apps/mobile/components/markdown/MarkdownRenderer.tsx:
```typescript
import { StyleSheet, ScrollView } from "react-native";
import Markdown from "react-native-markdown-display";

interface MarkdownRendererProps {
  content: string;
}

const markdownStyles = StyleSheet.create({
  body: {
    color: "#1a1a1a",
    fontSize: 16,
    lineHeight: 24,
  },
  heading1: {
    fontSize: 28,
    fontWeight: "bold",
    marginTop: 16,
    marginBottom: 8,
    color: "#1a1a1a",
  },
  heading2: {
    fontSize: 24,
    fontWeight: "bold",
    marginTop: 14,
    marginBottom: 6,
    color: "#1a1a1a",
  },
  heading3: {
    fontSize: 20,
    fontWeight: "600",
    marginTop: 12,
    marginBottom: 4,
    color: "#1a1a1a",
  },
  paragraph: {
    marginVertical: 8,
  },
  code_inline: {
    backgroundColor: "#f4f4f4",
    fontFamily: "Courier",
    fontSize: 14,
    paddingHorizontal: 6,
    paddingVertical: 2,
    borderRadius: 4,
  },
  fence: {
    backgroundColor: "#f4f4f4",
    padding: 12,
    borderRadius: 8,
    fontFamily: "Courier",
    fontSize: 14,
    marginVertical: 8,
  },
  blockquote: {
    backgroundColor: "#f9f9f9",
    borderLeftWidth: 4,
    borderLeftColor: "#007AFF",
    paddingLeft: 12,
    paddingVertical: 8,
    marginVertical: 8,
  },
  bullet_list: {
    marginVertical: 8,
  },
  ordered_list: {
    marginVertical: 8,
  },
  list_item: {
    flexDirection: "row",
    marginVertical: 4,
  },
  link: {
    color: "#007AFF",
    textDecorationLine: "underline",
  },
  hr: {
    backgroundColor: "#E5E5EA",
    height: 1,
    marginVertical: 16,
  },
  strong: {
    fontWeight: "bold",
  },
  em: {
    fontStyle: "italic",
  },
});

export function MarkdownRenderer({ content }: MarkdownRendererProps) {
  return (
    <ScrollView style={styles.container}>
      <Markdown style={markdownStyles}>{content}</Markdown>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
  },
});
```

Create apps/mobile/components/markdown/MarkdownEditor.tsx:
```typescript
import { useState } from "react";
import {
  View,
  TextInput,
  TouchableOpacity,
  Text,
  StyleSheet,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { MarkdownRenderer } from "./MarkdownRenderer";

interface MarkdownEditorProps {
  value: string;
  onChangeText: (text: string) => void;
  placeholder?: string;
}

export function MarkdownEditor({
  value,
  onChangeText,
  placeholder = "Start writing...",
}: MarkdownEditorProps) {
  const [isPreview, setIsPreview] = useState(false);

  return (
    <View style={styles.container}>
      {/* Toggle Bar */}
      <View style={styles.toggleBar}>
        <TouchableOpacity
          style={[styles.toggleButton, !isPreview && styles.toggleActive]}
          onPress={() => setIsPreview(false)}
        >
          <Ionicons
            name="create-outline"
            size={18}
            color={!isPreview ? "#007AFF" : "#666"}
          />
          <Text style={[styles.toggleText, !isPreview && styles.toggleTextActive]}>
            Edit
          </Text>
        </TouchableOpacity>
        <TouchableOpacity
          style={[styles.toggleButton, isPreview && styles.toggleActive]}
          onPress={() => setIsPreview(true)}
        >
          <Ionicons
            name="eye-outline"
            size={18}
            color={isPreview ? "#007AFF" : "#666"}
          />
          <Text style={[styles.toggleText, isPreview && styles.toggleTextActive]}>
            Preview
          </Text>
        </TouchableOpacity>
      </View>

      {/* Content Area */}
      <KeyboardAvoidingView
        style={styles.content}
        behavior={Platform.OS === "ios" ? "padding" : undefined}
        keyboardVerticalOffset={120}
      >
        {isPreview ? (
          <MarkdownRenderer content={value || "*No content yet*"} />
        ) : (
          <ScrollView
            style={styles.scrollView}
            keyboardShouldPersistTaps="handled"
          >
            <TextInput
              style={styles.textInput}
              value={value}
              onChangeText={onChangeText}
              placeholder={placeholder}
              placeholderTextColor="#999"
              multiline
              textAlignVertical="top"
            />
          </ScrollView>
        )}
      </KeyboardAvoidingView>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  toggleBar: {
    flexDirection: "row",
    backgroundColor: "#F2F2F7",
    padding: 4,
    marginHorizontal: 16,
    marginVertical: 8,
    borderRadius: 10,
  },
  toggleButton: {
    flex: 1,
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "center",
    paddingVertical: 8,
    borderRadius: 8,
    gap: 4,
  },
  toggleActive: {
    backgroundColor: "#fff",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.1,
    shadowRadius: 2,
    elevation: 2,
  },
  toggleText: {
    fontSize: 14,
    fontWeight: "500",
    color: "#666",
  },
  toggleTextActive: {
    color: "#007AFF",
  },
  content: {
    flex: 1,
  },
  scrollView: {
    flex: 1,
  },
  textInput: {
    flex: 1,
    fontSize: 16,
    lineHeight: 24,
    padding: 16,
    color: "#1a1a1a",
    minHeight: 300,
  },
});
```

Update apps/mobile/app/(app)/notes/[id].tsx to use MarkdownEditor:

Replace the content TextInput with the MarkdownEditor component:
```typescript
import { MarkdownEditor } from "@/components/markdown/MarkdownEditor";

// In the JSX, replace the contentInput with:
<MarkdownEditor
  value={content}
  onChangeText={handleContentChange}
  placeholder="Start writing in markdown..."
/>
```

Remove the old contentInput from the editor and update styles if needed. The title input stays separate at the top.
  </action>
  <verify>
- MarkdownRenderer.tsx exists with proper markdown styles
- MarkdownEditor.tsx exists with edit/preview toggle
- Note editor shows toggle bar between title and content
- Edit mode shows TextInput with markdown source
- Preview mode shows rendered markdown
- Headers, lists, code blocks, links render correctly
- Toggle animation is smooth
- TypeScript compiles: `cd apps/mobile && pnpm exec tsc --noEmit`
  </verify>
  <done>Markdown editor with edit/preview toggle and styled rendering complete</done>
</task>

<task type="auto">
  <name>Task 3: Create move note functionality</name>
  <files>
    apps/mobile/components/notes/MoveNoteModal.tsx
    apps/mobile/app/(app)/notes/[id].tsx
  </files>
  <action>
Create apps/mobile/components/notes/MoveNoteModal.tsx:
```typescript
import { useState, useEffect } from "react";
import {
  View,
  Text,
  Modal,
  TouchableOpacity,
  FlatList,
  StyleSheet,
  SafeAreaView,
} from "react-native";
import { Ionicons } from "@expo/vector-icons";
import { getFolders, getFolderPath, type Folder } from "@/db/queries";

interface MoveNoteModalProps {
  visible: boolean;
  currentFolderId: number | null;
  onClose: () => void;
  onSelect: (folderId: number | null) => void;
}

export function MoveNoteModal({
  visible,
  currentFolderId,
  onClose,
  onSelect,
}: MoveNoteModalProps) {
  const [parentId, setParentId] = useState<number | null>(null);
  const [folders, setFolders] = useState<Folder[]>([]);
  const [breadcrumbs, setBreadcrumbs] = useState<Folder[]>([]);

  // Load folders at current level
  useEffect(() => {
    if (visible) {
      loadFolders(null);
    }
  }, [visible]);

  const loadFolders = async (folderId: number | null) => {
    const items = await getFolders(folderId);
    setFolders(items);
    setParentId(folderId);

    // Update breadcrumbs
    if (folderId === null) {
      setBreadcrumbs([]);
    } else {
      const path = await getFolderPath(folderId);
      setBreadcrumbs(path);
    }
  };

  const handleFolderPress = (folder: Folder) => {
    loadFolders(folder.id);
  };

  const handleBack = () => {
    if (breadcrumbs.length > 1) {
      // Go to parent of current folder
      loadFolders(breadcrumbs[breadcrumbs.length - 2].parentId ?? null);
    } else {
      // Go to root
      loadFolders(null);
    }
  };

  const handleSelect = () => {
    onSelect(parentId);
    onClose();
  };

  const isCurrentLocation = parentId === currentFolderId;

  return (
    <Modal visible={visible} animationType="slide">
      <SafeAreaView style={styles.container}>
        {/* Header */}
        <View style={styles.header}>
          <TouchableOpacity onPress={onClose} style={styles.headerButton}>
            <Text style={styles.cancelText}>Cancel</Text>
          </TouchableOpacity>
          <Text style={styles.title}>Move to</Text>
          <TouchableOpacity
            onPress={handleSelect}
            style={styles.headerButton}
            disabled={isCurrentLocation}
          >
            <Text
              style={[
                styles.selectText,
                isCurrentLocation && styles.selectDisabled,
              ]}
            >
              Select
            </Text>
          </TouchableOpacity>
        </View>

        {/* Breadcrumb / Back */}
        {breadcrumbs.length > 0 && (
          <TouchableOpacity style={styles.backButton} onPress={handleBack}>
            <Ionicons name="chevron-back" size={20} color="#007AFF" />
            <Text style={styles.backText}>
              {breadcrumbs.length > 1
                ? breadcrumbs[breadcrumbs.length - 2].name
                : "Notes"}
            </Text>
          </TouchableOpacity>
        )}

        {/* Current Location Label */}
        <View style={styles.currentLocation}>
          <Text style={styles.currentLabel}>
            {parentId === null
              ? "Root (Notes)"
              : breadcrumbs[breadcrumbs.length - 1]?.name || ""}
          </Text>
          {isCurrentLocation && (
            <Text style={styles.currentNote}>Current location</Text>
          )}
        </View>

        {/* Folder List */}
        <FlatList
          data={folders}
          keyExtractor={(item) => item.id.toString()}
          renderItem={({ item }) => (
            <TouchableOpacity
              style={styles.folderItem}
              onPress={() => handleFolderPress(item)}
            >
              <Ionicons name="folder" size={24} color="#007AFF" />
              <Text style={styles.folderName}>{item.name}</Text>
              <Ionicons name="chevron-forward" size={20} color="#C7C7CC" />
            </TouchableOpacity>
          )}
          ListEmptyComponent={
            <View style={styles.emptyContainer}>
              <Text style={styles.emptyText}>No subfolders</Text>
            </View>
          }
          contentContainerStyle={styles.listContent}
        />
      </SafeAreaView>
    </Modal>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: "#F2F2F7",
  },
  header: {
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "space-between",
    paddingHorizontal: 16,
    paddingVertical: 12,
    backgroundColor: "#fff",
    borderBottomWidth: 1,
    borderBottomColor: "#E5E5EA",
  },
  headerButton: {
    padding: 4,
  },
  title: {
    fontSize: 17,
    fontWeight: "600",
    color: "#1a1a1a",
  },
  cancelText: {
    fontSize: 17,
    color: "#007AFF",
  },
  selectText: {
    fontSize: 17,
    fontWeight: "600",
    color: "#007AFF",
  },
  selectDisabled: {
    color: "#C7C7CC",
  },
  backButton: {
    flexDirection: "row",
    alignItems: "center",
    padding: 16,
    backgroundColor: "#fff",
    borderBottomWidth: 1,
    borderBottomColor: "#E5E5EA",
  },
  backText: {
    fontSize: 17,
    color: "#007AFF",
    marginLeft: 4,
  },
  currentLocation: {
    padding: 16,
    backgroundColor: "#fff",
    borderBottomWidth: 1,
    borderBottomColor: "#E5E5EA",
  },
  currentLabel: {
    fontSize: 17,
    fontWeight: "600",
    color: "#1a1a1a",
  },
  currentNote: {
    fontSize: 13,
    color: "#666",
    marginTop: 4,
  },
  listContent: {
    paddingTop: 8,
  },
  folderItem: {
    flexDirection: "row",
    alignItems: "center",
    backgroundColor: "#fff",
    padding: 16,
    marginHorizontal: 16,
    marginVertical: 4,
    borderRadius: 10,
  },
  folderName: {
    flex: 1,
    fontSize: 17,
    color: "#1a1a1a",
    marginLeft: 12,
  },
  emptyContainer: {
    padding: 32,
    alignItems: "center",
  },
  emptyText: {
    fontSize: 15,
    color: "#666",
  },
});
```

Update apps/mobile/app/(app)/notes/[id].tsx to add move functionality:

Add state and handler:
```typescript
import { MoveNoteModal } from "@/components/notes/MoveNoteModal";
import { moveNote } from "@/db/queries";

// Add state:
const [showMoveModal, setShowMoveModal] = useState(false);

// Add handler:
const handleMove = async (newFolderId: number | null) => {
  await moveNote(noteId, newFolderId);
  // Note: useLiveQuery will update the note data automatically
};
```

Add move button to header (next to delete):
```typescript
<Stack.Screen
  options={{
    title: "",
    headerRight: () => (
      <View style={{ flexDirection: "row", gap: 8 }}>
        <TouchableOpacity
          onPress={() => setShowMoveModal(true)}
          style={styles.headerButton}
        >
          <Ionicons name="folder-outline" size={24} color="#007AFF" />
        </TouchableOpacity>
        <TouchableOpacity onPress={handleDelete} style={styles.headerButton}>
          <Ionicons name="trash-outline" size={24} color="#FF3B30" />
        </TouchableOpacity>
      </View>
    ),
  }}
/>
```

Add modal at end of component, before closing tags:
```typescript
<MoveNoteModal
  visible={showMoveModal}
  currentFolderId={note.folderId}
  onClose={() => setShowMoveModal(false)}
  onSelect={handleMove}
/>
```

Add headerButton style:
```typescript
headerButton: {
  padding: 8,
},
```
  </action>
  <verify>
- MoveNoteModal.tsx exists with folder picker
- Note editor has folder icon in header
- Tapping folder icon opens move modal
- Modal shows folder hierarchy with navigation
- Selecting folder moves note
- Current location is indicated and disabled
- Move reflects immediately in UI (useLiveQuery)
- TypeScript compiles: `cd apps/mobile && pnpm exec tsc --noEmit`
  </verify>
  <done>Move note functionality with folder picker modal complete</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete Phase 2 note-taking functionality:
1. SQLite database with notes and folders tables
2. Note list and folder navigation
3. Note editor with autosave
4. Markdown edit/preview toggle
5. Full-text search with FTS5
6. Move notes between folders
  </what-built>
  <how-to-verify>
Test all 5 success criteria:

1. **Create, edit, delete notes:**
   - Open app, navigate to Notes from home
   - Tap + to create new note
   - Type title and content (use markdown like `# Header` and `- list item`)
   - Wait 1 second for autosave
   - Navigate back, note should appear in list
   - Tap note to reopen, verify content saved
   - Delete note from header trash icon

2. **Organize notes in nested folders:**
   - Create folder from + menu
   - Navigate into folder
   - Create subfolder inside it
   - Create note inside subfolder

3. **Move notes between folders:**
   - Open a note
   - Tap folder icon in header
   - Navigate to different folder
   - Tap Select to move
   - Verify note appears in new folder

4. **Search across all notes:**
   - Create several notes with different content
   - Tap search icon in notes header
   - Type keyword from one note
   - Verify matching note appears in results
   - Tap result to open note

5. **Markdown rendering:**
   - Create note with markdown content:
     ```
     # Heading 1
     ## Heading 2
     - Bullet item
     1. Numbered item
     **bold** and *italic*
     `inline code`
     ```
   - Tap Preview toggle
   - Verify all formatting renders correctly
  </how-to-verify>
  <resume-signal>Type "approved" if all criteria pass, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete (including human verification):

1. **All Success Criteria:**
   - [ ] User can create, edit, and delete markdown notes
   - [ ] User can organize notes in nested folders
   - [ ] User can move notes between folders
   - [ ] User can search across all note content and find matches instantly
   - [ ] Markdown renders correctly with headers, lists, code blocks, and formatting

2. **Build Check:**
   - `cd apps/mobile && pnpm exec tsc --noEmit` passes
   - App runs without console errors
   - All screens accessible via navigation

3. **Data Integrity:**
   - Notes persist across app restart
   - Folder hierarchy maintained correctly
   - FTS index stays in sync with note changes
</verification>

<success_criteria>
- Search screen returns relevant results with snippets
- Markdown editor has working edit/preview toggle
- Markdown renders all common elements correctly
- Move modal shows folder hierarchy
- Notes can be moved to any folder or root
- All Phase 2 requirements complete (NOTE-01 through NOTE-05)
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-note-taking/02-05-SUMMARY.md`
</output>
