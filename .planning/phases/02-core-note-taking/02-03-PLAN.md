---
phase: 02-core-note-taking
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/mobile/db/migrations/0002_fts5.sql
  - apps/mobile/db/client.ts
  - apps/mobile/db/queries/search.ts
  - apps/mobile/db/queries/index.ts
autonomous: true

must_haves:
  truths:
    - "Full-text search returns notes matching query"
    - "Search results are ranked by relevance (bm25)"
    - "FTS index stays in sync when notes are created/updated/deleted"
    - "Search is instant (no full table scan)"
  artifacts:
    - path: "apps/mobile/db/migrations/0002_fts5.sql"
      provides: "FTS5 virtual table and sync triggers"
      contains: "CREATE VIRTUAL TABLE"
    - path: "apps/mobile/db/queries/search.ts"
      provides: "Search query function"
      exports: ["searchNotes"]
  key_links:
    - from: "apps/mobile/db/queries/search.ts"
      to: "notes_fts"
      via: "MATCH query"
      pattern: "MATCH"
    - from: "apps/mobile/db/migrations/0002_fts5.sql"
      to: "notes table"
      via: "triggers"
      pattern: "TRIGGER.*notes"
---

<objective>
Set up FTS5 full-text search with automatic index synchronization via triggers.

Purpose: Enable instant search across all note content. FTS5 provides relevance-ranked results without full table scans, essential for a note-taking app with potentially thousands of notes.

Output: FTS5 virtual table indexed on note title and content, with INSERT/UPDATE/DELETE triggers to keep the index in sync. Search query function returns ranked results.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-note-taking/02-01-SUMMARY.md
@apps/mobile/db/schema.ts
@apps/mobile/db/client.ts
@apps/mobile/db/migrations/0001_initial.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FTS5 migration with triggers</name>
  <files>
    apps/mobile/db/migrations/0002_fts5.sql
  </files>
  <action>
Create apps/mobile/db/migrations/0002_fts5.sql:

```sql
-- FTS5 virtual table for full-text search on notes
-- Using external content table pattern to avoid data duplication
CREATE VIRTUAL TABLE IF NOT EXISTS notes_fts USING fts5(
  title,
  content,
  content='notes',
  content_rowid='rowid'
);

-- Populate FTS index from existing notes (for initial migration)
INSERT INTO notes_fts(notes_fts) VALUES('rebuild');

-- Trigger: Keep FTS in sync on INSERT
CREATE TRIGGER IF NOT EXISTS notes_fts_insert AFTER INSERT ON notes BEGIN
  INSERT INTO notes_fts(rowid, title, content)
  VALUES (NEW.rowid, NEW.title, NEW.content);
END;

-- Trigger: Keep FTS in sync on UPDATE
CREATE TRIGGER IF NOT EXISTS notes_fts_update AFTER UPDATE ON notes BEGIN
  INSERT INTO notes_fts(notes_fts, rowid, title, content)
  VALUES ('delete', OLD.rowid, OLD.title, OLD.content);
  INSERT INTO notes_fts(rowid, title, content)
  VALUES (NEW.rowid, NEW.title, NEW.content);
END;

-- Trigger: Keep FTS in sync on DELETE
CREATE TRIGGER IF NOT EXISTS notes_fts_delete AFTER DELETE ON notes BEGIN
  INSERT INTO notes_fts(notes_fts, rowid, title, content)
  VALUES ('delete', OLD.rowid, OLD.title, OLD.content);
END;
```

IMPORTANT: FTS5 external content tables require rowid mapping. SQLite auto-generates rowid for tables without explicit INTEGER PRIMARY KEY. Our notes table uses TEXT id, so SQLite will auto-create a rowid column.

The 'rebuild' command populates the FTS index from existing content in the notes table.
  </action>
  <verify>
File exists at apps/mobile/db/migrations/0002_fts5.sql with CREATE VIRTUAL TABLE and three triggers.
  </verify>
  <done>FTS5 migration created with external content table and INSERT/UPDATE/DELETE triggers</done>
</task>

<task type="auto">
  <name>Task 2: Update migration runner to include FTS5</name>
  <files>
    apps/mobile/db/client.ts
  </files>
  <action>
Update apps/mobile/db/client.ts to run the FTS5 migration:

```typescript
import { drizzle } from 'drizzle-orm/expo-sqlite';
import { openDatabaseSync } from 'expo-sqlite';
import * as schema from './schema';

// Import migration SQL files
import migration0001 from './migrations/0001_initial.sql';
import migration0002 from './migrations/0002_fts5.sql';

const expo = openDatabaseSync('k7notes.db', { enableChangeListener: true });

export const db = drizzle(expo, { schema });

// Run migrations on app start
export async function runMigrations() {
  // Run migrations in order
  // Each migration is idempotent (IF NOT EXISTS)
  expo.execSync(migration0001);
  expo.execSync(migration0002);
  console.log('[DB] Migrations complete');
}

// Export raw expo-sqlite for useLiveQuery
export { expo };
```

Note: Migrations are idempotent due to IF NOT EXISTS clauses. Safe to re-run.
  </action>
  <verify>
Run `pnpm --filter @k7notes/mobile type-check` to confirm TypeScript compiles.
Start app and verify console shows "[DB] Migrations complete" without FTS5 errors.
  </verify>
  <done>Migration runner updated to execute FTS5 migration</done>
</task>

<task type="auto">
  <name>Task 3: Create search query function</name>
  <files>
    apps/mobile/db/queries/search.ts
    apps/mobile/db/queries/index.ts
  </files>
  <action>
Create apps/mobile/db/queries/search.ts:

```typescript
import { sql } from 'drizzle-orm';
import { db, expo } from '../client';
import { notes, Note } from '../schema';

/**
 * Search result with relevance score
 */
export interface SearchResult {
  note: Note;
  rank: number;
  snippet: string;
}

/**
 * Search notes using FTS5 full-text search
 * Returns results ranked by bm25 relevance score
 *
 * @param query - Search query string (supports FTS5 syntax: AND, OR, quotes for phrases)
 * @param limit - Maximum results to return (default 50)
 */
export async function searchNotes(query: string, limit = 50): Promise<SearchResult[]> {
  if (!query.trim()) {
    return [];
  }

  // Escape special FTS5 characters and add wildcards for prefix matching
  // This allows partial word matching (e.g., "meet" matches "meeting")
  const searchTerms = query
    .trim()
    .split(/\s+/)
    .map((term) => `"${term}"*`)
    .join(' ');

  // Use raw SQL for FTS5 query with bm25 ranking
  // Join with notes table to get full note data
  const results = expo.getAllSync<{
    id: string;
    title: string;
    content: string;
    folder_id: string | null;
    created_at: number;
    updated_at: number;
    rank: number;
    snippet: string;
  }>(
    `
    SELECT
      notes.id,
      notes.title,
      notes.content,
      notes.folder_id,
      notes.created_at,
      notes.updated_at,
      bm25(notes_fts) as rank,
      snippet(notes_fts, 1, '<mark>', '</mark>', '...', 32) as snippet
    FROM notes_fts
    JOIN notes ON notes.rowid = notes_fts.rowid
    WHERE notes_fts MATCH ?
    ORDER BY rank
    LIMIT ?
    `,
    [searchTerms, limit]
  );

  return results.map((row) => ({
    note: {
      id: row.id,
      title: row.title,
      content: row.content,
      folderId: row.folder_id,
      createdAt: new Date(row.created_at),
      updatedAt: new Date(row.updated_at),
    },
    rank: row.rank,
    snippet: row.snippet,
  }));
}

/**
 * Rebuild the FTS index from scratch
 * Useful if index gets out of sync (should rarely be needed due to triggers)
 */
export async function rebuildSearchIndex(): Promise<void> {
  expo.execSync("INSERT INTO notes_fts(notes_fts) VALUES('rebuild')");
  console.log('[DB] FTS index rebuilt');
}
```

Update apps/mobile/db/queries/index.ts to include search:
```typescript
export * from './notes';
export * from './folders';
export * from './search';
```
  </action>
  <verify>
Run `pnpm --filter @k7notes/mobile type-check` to confirm TypeScript compiles.
  </verify>
  <done>Search query function created with bm25 ranking and snippet extraction</done>
</task>

</tasks>

<verification>
1. `pnpm --filter @k7notes/mobile type-check` passes
2. App starts without FTS5 errors
3. FTS5 triggers created in database (can verify via sqlite browser)
4. searchNotes function compiles with correct types
</verification>

<success_criteria>
- FTS5 virtual table notes_fts created with title and content columns
- External content table pattern used (content='notes')
- INSERT, UPDATE, DELETE triggers keep FTS in sync
- searchNotes function returns ranked results with snippets
- bm25 ranking provides relevance-based ordering
- Prefix matching enabled for partial word search
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-note-taking/02-03-SUMMARY.md`
</output>
