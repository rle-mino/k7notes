---
phase: 02-core-note-taking
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/mobile/db/queries/notes.ts
  - apps/mobile/db/queries/folders.ts
  - apps/mobile/db/queries/index.ts
  - apps/mobile/db/hooks/useLiveQuery.ts
  - apps/mobile/db/hooks/index.ts
autonomous: true

must_haves:
  truths:
    - "Notes can be created with title and content"
    - "Notes can be read by ID and listed by folder"
    - "Notes can be updated (title, content, folder)"
    - "Notes can be deleted"
    - "Folders can be created with optional parent"
    - "Folders can list their children (subfolders and notes)"
    - "Queries re-run automatically when data changes"
  artifacts:
    - path: "apps/mobile/db/queries/notes.ts"
      provides: "Note CRUD functions"
      exports: ["createNote", "getNote", "listNotes", "updateNote", "deleteNote"]
    - path: "apps/mobile/db/queries/folders.ts"
      provides: "Folder CRUD functions"
      exports: ["createFolder", "getFolder", "listFolders", "updateFolder", "deleteFolder", "getFolderContents"]
    - path: "apps/mobile/db/hooks/useLiveQuery.ts"
      provides: "Reactive query hook"
      exports: ["useLiveQuery"]
  key_links:
    - from: "apps/mobile/db/queries/notes.ts"
      to: "apps/mobile/db/schema.ts"
      via: "import { notes }"
      pattern: "from.*schema"
    - from: "apps/mobile/db/hooks/useLiveQuery.ts"
      to: "expo-sqlite"
      via: "addDatabaseChangeListener"
      pattern: "addDatabaseChangeListener"
---

<objective>
Implement CRUD operations for notes and folders with reactive queries using useLiveQuery hook.

Purpose: Provide the data access layer that UI components will use. Reactive queries ensure the UI updates automatically when notes or folders change.

Output: Type-safe query functions for notes and folders, plus a useLiveQuery hook that re-fetches data when the database changes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-note-taking/02-01-SUMMARY.md
@apps/mobile/db/schema.ts
@apps/mobile/db/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useLiveQuery hook for reactive data</name>
  <files>
    apps/mobile/db/hooks/useLiveQuery.ts
    apps/mobile/db/hooks/index.ts
  </files>
  <action>
Create apps/mobile/db/hooks/useLiveQuery.ts that wraps expo-sqlite's change listener:

```typescript
import { useEffect, useState, useCallback } from 'react';
import { addDatabaseChangeListener } from 'expo-sqlite';
import { expo } from '../client';

/**
 * Hook that re-runs a query function when any table in the database changes.
 * Uses expo-sqlite's enableChangeListener feature.
 *
 * @param queryFn - Async function that returns data from the database
 * @param deps - Additional dependencies that should trigger re-fetch
 * @returns { data, loading, error, refetch }
 */
export function useLiveQuery<T>(
  queryFn: () => Promise<T>,
  deps: unknown[] = []
) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  const fetchData = useCallback(async () => {
    try {
      setLoading(true);
      const result = await queryFn();
      setData(result);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Query failed'));
    } finally {
      setLoading(false);
    }
  }, [queryFn, ...deps]);

  // Initial fetch
  useEffect(() => {
    fetchData();
  }, [fetchData]);

  // Subscribe to database changes
  useEffect(() => {
    const subscription = addDatabaseChangeListener(expo, () => {
      fetchData();
    });

    return () => {
      subscription.remove();
    };
  }, [fetchData]);

  return { data, loading, error, refetch: fetchData };
}
```

Create apps/mobile/db/hooks/index.ts:
```typescript
export { useLiveQuery } from './useLiveQuery';
```

Update apps/mobile/db/index.ts to also export hooks:
```typescript
export * from './schema';
export * from './client';
export * from './hooks';
```
  </action>
  <verify>
Run `pnpm --filter @k7notes/mobile type-check` to confirm TypeScript compiles.
  </verify>
  <done>useLiveQuery hook created with database change subscription</done>
</task>

<task type="auto">
  <name>Task 2: Create note CRUD query functions</name>
  <files>
    apps/mobile/db/queries/notes.ts
    apps/mobile/db/queries/index.ts
  </files>
  <action>
Create apps/mobile/db/queries/notes.ts with type-safe Drizzle queries:

```typescript
import { eq, desc, isNull } from 'drizzle-orm';
import { db } from '../client';
import { notes, Note, NewNote } from '../schema';

// Generate UUID for new records
function generateId(): string {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === 'x' ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

/**
 * Create a new note
 */
export async function createNote(data: {
  title: string;
  content?: string;
  folderId?: string | null;
}): Promise<Note> {
  const now = new Date();
  const newNote: NewNote = {
    id: generateId(),
    title: data.title,
    content: data.content ?? '',
    folderId: data.folderId ?? null,
    createdAt: now,
    updatedAt: now,
  };

  await db.insert(notes).values(newNote);
  return { ...newNote, createdAt: now, updatedAt: now };
}

/**
 * Get a note by ID
 */
export async function getNote(id: string): Promise<Note | null> {
  const results = await db.select().from(notes).where(eq(notes.id, id)).limit(1);
  return results[0] ?? null;
}

/**
 * List notes in a folder (or root if folderId is null)
 * Ordered by updatedAt descending (most recent first)
 */
export async function listNotes(folderId: string | null = null): Promise<Note[]> {
  if (folderId === null) {
    return db
      .select()
      .from(notes)
      .where(isNull(notes.folderId))
      .orderBy(desc(notes.updatedAt));
  }
  return db
    .select()
    .from(notes)
    .where(eq(notes.folderId, folderId))
    .orderBy(desc(notes.updatedAt));
}

/**
 * List all notes (for search purposes)
 */
export async function listAllNotes(): Promise<Note[]> {
  return db.select().from(notes).orderBy(desc(notes.updatedAt));
}

/**
 * Update a note
 */
export async function updateNote(
  id: string,
  data: Partial<Pick<Note, 'title' | 'content' | 'folderId'>>
): Promise<Note | null> {
  const now = new Date();
  await db
    .update(notes)
    .set({ ...data, updatedAt: now })
    .where(eq(notes.id, id));
  return getNote(id);
}

/**
 * Delete a note
 */
export async function deleteNote(id: string): Promise<void> {
  await db.delete(notes).where(eq(notes.id, id));
}

/**
 * Move a note to a different folder
 */
export async function moveNote(id: string, folderId: string | null): Promise<Note | null> {
  return updateNote(id, { folderId });
}
```

Create apps/mobile/db/queries/index.ts:
```typescript
export * from './notes';
export * from './folders';
```

Update apps/mobile/db/index.ts to also export queries:
```typescript
export * from './schema';
export * from './client';
export * from './hooks';
export * from './queries';
```
  </action>
  <verify>
Run `pnpm --filter @k7notes/mobile type-check` to confirm TypeScript compiles.
  </verify>
  <done>Note CRUD functions created: createNote, getNote, listNotes, listAllNotes, updateNote, deleteNote, moveNote</done>
</task>

<task type="auto">
  <name>Task 3: Create folder CRUD query functions</name>
  <files>
    apps/mobile/db/queries/folders.ts
  </files>
  <action>
Create apps/mobile/db/queries/folders.ts:

```typescript
import { eq, isNull, desc } from 'drizzle-orm';
import { db } from '../client';
import { folders, notes, Folder, NewFolder, Note } from '../schema';

// Generate UUID for new records
function generateId(): string {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = (Math.random() * 16) | 0;
    const v = c === 'x' ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

/**
 * Create a new folder
 */
export async function createFolder(data: {
  name: string;
  parentId?: string | null;
}): Promise<Folder> {
  const now = new Date();
  const newFolder: NewFolder = {
    id: generateId(),
    name: data.name,
    parentId: data.parentId ?? null,
    createdAt: now,
    updatedAt: now,
  };

  await db.insert(folders).values(newFolder);
  return { ...newFolder, createdAt: now, updatedAt: now };
}

/**
 * Get a folder by ID
 */
export async function getFolder(id: string): Promise<Folder | null> {
  const results = await db.select().from(folders).where(eq(folders.id, id)).limit(1);
  return results[0] ?? null;
}

/**
 * List folders in a parent folder (or root if parentId is null)
 */
export async function listFolders(parentId: string | null = null): Promise<Folder[]> {
  if (parentId === null) {
    return db
      .select()
      .from(folders)
      .where(isNull(folders.parentId))
      .orderBy(folders.name);
  }
  return db
    .select()
    .from(folders)
    .where(eq(folders.parentId, parentId))
    .orderBy(folders.name);
}

/**
 * List all folders (for move dialog, folder picker)
 */
export async function listAllFolders(): Promise<Folder[]> {
  return db.select().from(folders).orderBy(folders.name);
}

/**
 * Update a folder
 */
export async function updateFolder(
  id: string,
  data: Partial<Pick<Folder, 'name' | 'parentId'>>
): Promise<Folder | null> {
  const now = new Date();
  await db
    .update(folders)
    .set({ ...data, updatedAt: now })
    .where(eq(folders.id, id));
  return getFolder(id);
}

/**
 * Delete a folder (cascades to subfolders, sets notes.folder_id to null)
 */
export async function deleteFolder(id: string): Promise<void> {
  await db.delete(folders).where(eq(folders.id, id));
}

/**
 * Get folder contents (subfolders and notes)
 * Returns both for display in folder view
 */
export async function getFolderContents(folderId: string | null): Promise<{
  folders: Folder[];
  notes: Note[];
}> {
  const [folderList, noteList] = await Promise.all([
    listFolders(folderId),
    folderId === null
      ? db.select().from(notes).where(isNull(notes.folderId)).orderBy(desc(notes.updatedAt))
      : db.select().from(notes).where(eq(notes.folderId, folderId)).orderBy(desc(notes.updatedAt)),
  ]);

  return { folders: folderList, notes: noteList };
}

/**
 * Get folder path (breadcrumb) from root to given folder
 * Uses recursive lookup (not CTE, for simplicity with small depth)
 */
export async function getFolderPath(folderId: string): Promise<Folder[]> {
  const path: Folder[] = [];
  let currentId: string | null = folderId;

  while (currentId) {
    const folder = await getFolder(currentId);
    if (!folder) break;
    path.unshift(folder); // Add to beginning for root-first order
    currentId = folder.parentId;
  }

  return path;
}
```
  </action>
  <verify>
Run `pnpm --filter @k7notes/mobile type-check` to confirm TypeScript compiles.
  </verify>
  <done>Folder CRUD functions created: createFolder, getFolder, listFolders, listAllFolders, updateFolder, deleteFolder, getFolderContents, getFolderPath</done>
</task>

</tasks>

<verification>
1. `pnpm --filter @k7notes/mobile type-check` passes
2. All query functions export correctly from apps/mobile/db/index.ts
3. useLiveQuery hook subscribes to database changes
4. Type inference works for Note and Folder types
</verification>

<success_criteria>
- Note CRUD: create, read, list, update, delete, move
- Folder CRUD: create, read, list, update, delete
- getFolderContents returns both subfolders and notes
- getFolderPath returns breadcrumb from root
- useLiveQuery hook re-fetches on database changes
- All functions are type-safe with proper TypeScript inference
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-note-taking/02-02-SUMMARY.md`
</output>
