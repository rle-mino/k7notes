---
phase: 02-core-note-taking
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - apps/mobile/db/queries/notes.ts
  - apps/mobile/db/queries/folders.ts
  - apps/mobile/db/queries/index.ts
autonomous: true

must_haves:
  truths:
    - "Notes can be created, read, updated, and deleted"
    - "Folders can be created, read, updated, and deleted"
    - "Folder hierarchy can be queried with recursive CTEs"
    - "Notes can be queried by folder (including root)"
  artifacts:
    - path: "apps/mobile/db/queries/notes.ts"
      provides: "Note CRUD operations"
      exports: ["createNote", "getNote", "getNotes", "updateNote", "deleteNote"]
    - path: "apps/mobile/db/queries/folders.ts"
      provides: "Folder CRUD and hierarchy operations"
      exports: ["createFolder", "getFolder", "getFolders", "getFolderTree", "updateFolder", "deleteFolder"]
  key_links:
    - from: "apps/mobile/db/queries/notes.ts"
      to: "apps/mobile/db/client.ts"
      via: "db import"
      pattern: "import.*db.*from"
    - from: "apps/mobile/db/queries/folders.ts"
      to: "apps/mobile/db/schema.ts"
      via: "schema tables"
      pattern: "import.*folders.*from"
---

<objective>
Implement CRUD operations for notes and folders with type-safe Drizzle queries

Purpose: Create the data access layer that UI components will use to manage notes and folders. This separates data concerns from presentation and provides a clean API for all note/folder operations.

Output: Query functions for note and folder CRUD, plus recursive folder hierarchy queries using SQLite CTEs.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-note-taking/02-RESEARCH.md

# Files from Plan 01
@apps/mobile/db/schema.ts
@apps/mobile/db/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create note query functions</name>
  <files>
    apps/mobile/db/queries/notes.ts
  </files>
  <action>
Create apps/mobile/db/queries/notes.ts with type-safe CRUD operations:

```typescript
import { eq, desc, isNull, sql } from "drizzle-orm";
import { db } from "../client";
import { notes } from "../schema";

// Types
export type Note = typeof notes.$inferSelect;
export type NewNote = typeof notes.$inferInsert;

// Create a new note
export async function createNote(data: {
  title: string;
  content?: string;
  folderId?: number | null;
}): Promise<Note> {
  const result = await db.insert(notes).values({
    title: data.title,
    content: data.content ?? "",
    folderId: data.folderId ?? null,
  }).returning();
  return result[0];
}

// Get a single note by ID
export async function getNote(id: number): Promise<Note | undefined> {
  const result = await db.select().from(notes).where(eq(notes.id, id));
  return result[0];
}

// Get all notes in a folder (null folderId = root level)
export async function getNotes(folderId?: number | null): Promise<Note[]> {
  if (folderId === undefined || folderId === null) {
    return db.select().from(notes)
      .where(isNull(notes.folderId))
      .orderBy(desc(notes.updatedAt));
  }
  return db.select().from(notes)
    .where(eq(notes.folderId, folderId))
    .orderBy(desc(notes.updatedAt));
}

// Get all notes (for search indexing or global views)
export async function getAllNotes(): Promise<Note[]> {
  return db.select().from(notes).orderBy(desc(notes.updatedAt));
}

// Update a note
export async function updateNote(
  id: number,
  data: { title?: string; content?: string; folderId?: number | null }
): Promise<Note | undefined> {
  const result = await db.update(notes)
    .set({
      ...data,
      updatedAt: new Date(),
    })
    .where(eq(notes.id, id))
    .returning();
  return result[0];
}

// Delete a note
export async function deleteNote(id: number): Promise<boolean> {
  const result = await db.delete(notes).where(eq(notes.id, id)).returning();
  return result.length > 0;
}

// Move note to a different folder
export async function moveNote(noteId: number, newFolderId: number | null): Promise<Note | undefined> {
  return updateNote(noteId, { folderId: newFolderId });
}
```
  </action>
  <verify>
- File exists at apps/mobile/db/queries/notes.ts
- Exports all required functions: createNote, getNote, getNotes, getAllNotes, updateNote, deleteNote, moveNote
- TypeScript compiles: `cd apps/mobile && pnpm exec tsc --noEmit`
- Types Note and NewNote are exported
  </verify>
  <done>Note CRUD operations ready with type-safe Drizzle queries</done>
</task>

<task type="auto">
  <name>Task 2: Create folder query functions with recursive hierarchy</name>
  <files>
    apps/mobile/db/queries/folders.ts
  </files>
  <action>
Create apps/mobile/db/queries/folders.ts with CRUD and hierarchy operations:

```typescript
import { eq, isNull, sql } from "drizzle-orm";
import { db } from "../client";
import { folders, notes } from "../schema";

// Types
export type Folder = typeof folders.$inferSelect;
export type NewFolder = typeof folders.$inferInsert;

export interface FolderWithMeta extends Folder {
  noteCount?: number;
  depth?: number;
  path?: string;
}

// Create a new folder
export async function createFolder(data: {
  name: string;
  parentId?: number | null;
}): Promise<Folder> {
  const result = await db.insert(folders).values({
    name: data.name,
    parentId: data.parentId ?? null,
  }).returning();
  return result[0];
}

// Get a single folder by ID
export async function getFolder(id: number): Promise<Folder | undefined> {
  const result = await db.select().from(folders).where(eq(folders.id, id));
  return result[0];
}

// Get folders at a specific level (null parentId = root level)
export async function getFolders(parentId?: number | null): Promise<Folder[]> {
  if (parentId === undefined || parentId === null) {
    return db.select().from(folders).where(isNull(folders.parentId));
  }
  return db.select().from(folders).where(eq(folders.parentId, parentId));
}

// Get folder tree using recursive CTE
// Returns all descendants of a folder (or all folders from root if no ID)
export async function getFolderTree(folderId?: number): Promise<FolderWithMeta[]> {
  const result = await db.all<FolderWithMeta>(sql`
    WITH RECURSIVE folder_tree(id, name, parent_id, created_at, updated_at, depth, path) AS (
      SELECT
        id,
        name,
        parent_id,
        created_at,
        updated_at,
        0 as depth,
        name as path
      FROM folders
      WHERE ${folderId ? sql`id = ${folderId}` : sql`parent_id IS NULL`}

      UNION ALL

      SELECT
        f.id,
        f.name,
        f.parent_id,
        f.created_at,
        f.updated_at,
        ft.depth + 1,
        ft.path || '/' || f.name
      FROM folders f
      JOIN folder_tree ft ON f.parent_id = ft.id
    )
    SELECT
      ft.*,
      (SELECT COUNT(*) FROM notes n WHERE n.folder_id = ft.id) as noteCount
    FROM folder_tree ft
    ORDER BY ft.path;
  `);
  return result;
}

// Get breadcrumb path to a folder (ancestors)
export async function getFolderPath(folderId: number): Promise<Folder[]> {
  const result = await db.all<Folder>(sql`
    WITH RECURSIVE ancestors(id, name, parent_id, created_at, updated_at, depth) AS (
      SELECT id, name, parent_id, created_at, updated_at, 0 as depth
      FROM folders
      WHERE id = ${folderId}

      UNION ALL

      SELECT f.id, f.name, f.parent_id, f.created_at, f.updated_at, a.depth + 1
      FROM folders f
      JOIN ancestors a ON f.id = a.parent_id
    )
    SELECT id, name, parent_id, created_at, updated_at
    FROM ancestors
    ORDER BY depth DESC;
  `);
  return result;
}

// Update a folder
export async function updateFolder(
  id: number,
  data: { name?: string; parentId?: number | null }
): Promise<Folder | undefined> {
  const result = await db.update(folders)
    .set({
      ...data,
      updatedAt: new Date(),
    })
    .where(eq(folders.id, id))
    .returning();
  return result[0];
}

// Delete a folder (cascade deletes children via FK constraint)
export async function deleteFolder(id: number): Promise<boolean> {
  const result = await db.delete(folders).where(eq(folders.id, id)).returning();
  return result.length > 0;
}

// Check if moving folder would create a cycle
export async function canMoveFolder(folderId: number, newParentId: number | null): Promise<boolean> {
  if (newParentId === null) return true; // Moving to root is always safe
  if (folderId === newParentId) return false; // Can't be own parent

  // Check if newParentId is a descendant of folderId
  const descendants = await getFolderTree(folderId);
  return !descendants.some(d => d.id === newParentId);
}

// Move folder to new parent (with cycle check)
export async function moveFolder(folderId: number, newParentId: number | null): Promise<Folder | undefined> {
  const canMove = await canMoveFolder(folderId, newParentId);
  if (!canMove) {
    throw new Error("Cannot move folder: would create circular reference");
  }
  return updateFolder(folderId, { parentId: newParentId });
}
```
  </action>
  <verify>
- File exists at apps/mobile/db/queries/folders.ts
- Exports: createFolder, getFolder, getFolders, getFolderTree, getFolderPath, updateFolder, deleteFolder, canMoveFolder, moveFolder
- TypeScript compiles: `cd apps/mobile && pnpm exec tsc --noEmit`
- Types Folder, NewFolder, FolderWithMeta exported
  </verify>
  <done>Folder CRUD and hierarchy operations ready with recursive CTE queries</done>
</task>

<task type="auto">
  <name>Task 3: Create query barrel export and verify all operations</name>
  <files>
    apps/mobile/db/queries/index.ts
  </files>
  <action>
Create apps/mobile/db/queries/index.ts as barrel export:

```typescript
// Note operations
export {
  createNote,
  getNote,
  getNotes,
  getAllNotes,
  updateNote,
  deleteNote,
  moveNote,
  type Note,
  type NewNote,
} from "./notes";

// Folder operations
export {
  createFolder,
  getFolder,
  getFolders,
  getFolderTree,
  getFolderPath,
  updateFolder,
  deleteFolder,
  canMoveFolder,
  moveFolder,
  type Folder,
  type NewFolder,
  type FolderWithMeta,
} from "./folders";
```

Test that exports work by adding a temporary test in a component or creating a simple test script. The key verification is that TypeScript compiles and the module structure is correct.

Also verify the path alias works by testing import in app code:
```typescript
import { createNote, createFolder, type Note } from "@/db/queries";
```
  </action>
  <verify>
- apps/mobile/db/queries/index.ts exists
- All exports are re-exported from index.ts
- `cd apps/mobile && pnpm exec tsc --noEmit` passes
- Path alias `@/db/queries` resolves correctly
  </verify>
  <done>Query layer complete with barrel exports for clean imports</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Module Structure:**
   - apps/mobile/db/queries/notes.ts exists with 7 exported functions
   - apps/mobile/db/queries/folders.ts exists with 9 exported functions
   - apps/mobile/db/queries/index.ts re-exports all

2. **Type Safety:**
   - `cd apps/mobile && pnpm exec tsc --noEmit` passes
   - No `any` types in query functions
   - Proper inference from Drizzle schema

3. **Import Paths:**
   - `@/db/queries` import works in app code
   - No circular dependencies

4. **Build Check:**
   - App still starts: `cd apps/mobile && npx expo start --clear`
   - No runtime errors when importing queries
</verification>

<success_criteria>
- All note CRUD operations implemented (create, read, update, delete, move)
- All folder CRUD operations implemented (create, read, update, delete, move)
- Recursive CTE queries work for folder hierarchy
- Cycle detection prevents invalid folder moves
- TypeScript types properly inferred from schema
- Clean barrel exports from @/db/queries
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-note-taking/02-02-SUMMARY.md`
</output>
