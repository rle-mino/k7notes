#!/bin/sh

# Pre-commit hook: runs lint-staged, tests, and E2E tests
# Requires Docker to be running for PostgreSQL container
#
# Turbo caching handles skipping unchanged packages automatically â€”
# if only docs/config files changed, test tasks will be cache hits.

set -e

echo "==> Pre-commit hook starting..."

# Change to repo root (where docker-compose lives)
REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT"

# Track if we started postgres (so we know whether to clean up)
POSTGRES_STARTED=0

# --- Helper functions ---

# Kill any processes listening on the given ports
kill_ports() {
    for port in "$@"; do
        pids=$(lsof -ti :"$port" 2>/dev/null || true)
        if [ -n "$pids" ]; then
            echo "    Killing processes on port $port (PIDs: $pids)"
            echo "$pids" | xargs kill -9 2>/dev/null || true
        fi
    done
}

# Cleanup function - stops containers and frees ports
cleanup() {
    echo "==> Cleaning up..."
    kill_ports 4000 4001
    if [ "$POSTGRES_STARTED" -eq 1 ]; then
        echo "    Stopping Docker containers..."
        docker compose -f packages/stack-k7/docker-compose.yml down --timeout 5 2>/dev/null || true
    fi
}

# Set trap to cleanup on exit (success or failure)
trap cleanup EXIT

# --- Pre-flight checks ---

# Check Docker is running
if ! docker info > /dev/null 2>&1; then
    echo "==> ERROR: Docker is not running. Start Docker Desktop and try again."
    exit 1
fi

# Free ports before we start anything (leftover from dev or previous failed runs)
echo "==> Freeing ports 4000, 4001 if occupied..."
kill_ports 4000 4001

# Step 1: Start PostgreSQL container
echo "==> Starting PostgreSQL container..."
docker compose -f packages/stack-k7/docker-compose.yml up -d
POSTGRES_STARTED=1

# Step 2: Wait for PostgreSQL to be healthy
echo "==> Waiting for PostgreSQL to be healthy..."
MAX_RETRIES=30
RETRY_COUNT=0
while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
    if docker compose -f packages/stack-k7/docker-compose.yml exec -T postgres pg_isready -U postgres -d k7notes > /dev/null 2>&1; then
        echo "==> PostgreSQL is ready!"
        break
    fi
    RETRY_COUNT=$((RETRY_COUNT + 1))
    if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
        echo "==> ERROR: PostgreSQL failed to become healthy after $MAX_RETRIES attempts"
        exit 1
    fi
    echo "    Waiting for PostgreSQL... (attempt $RETRY_COUNT/$MAX_RETRIES)"
    sleep 1
done

# Step 3: Run lint-staged (lints and type-checks staged files)
echo "==> Running lint-staged..."
pnpm lint-staged

# Step 4: Run unit & integration tests via Turbo
echo "==> Running unit & integration tests..."
pnpm turbo test

# Step 5: Run E2E tests (kill ports again in case unit tests started servers)
echo "==> Freeing ports before E2E tests..."
kill_ports 4000 4001
echo "==> Running E2E tests..."
pnpm turbo test:e2e

echo "==> Pre-commit hook completed successfully!"
